diff --git a/include/vlc_url.h b/include/vlc_url.h
index 448c685..e5b29eb 100644
--- a/include/vlc_url.h
+++ b/include/vlc_url.h
@@ -45,8 +45,6 @@ struct vlc_url_t
     char *psz_buffer; /* to be freed */
 };
 
-VLC_EXPORT( char *, unescape_URI_duplicate, ( const char *psz ) );
-VLC_EXPORT( void, unescape_URI, ( char *psz ) );
 VLC_EXPORT( char *, decode_URI_duplicate, ( const char *psz ) );
 VLC_EXPORT( char *, decode_URI, ( char *psz ) );
 VLC_EXPORT( char *, encode_URI_component, ( const char *psz ) );
diff --git a/modules/access/directory.c b/modules/access/directory.c
index 05b6ec1..dd04b6a 100644
--- a/modules/access/directory.c
+++ b/modules/access/directory.c
@@ -307,6 +307,7 @@ static block_t *Block (access_t *p_access)
     {   /* End of directory, go back to parent */
         closedir (current->handle);
         p_sys->current = current->parent;
+        free (current->uri);
         free (current);
 
         if (p_sys->current == NULL)
@@ -346,14 +347,20 @@ static block_t *Block (access_t *p_access)
 
     /* Skip current, parent and hidden directories */
     if (entry[0] == '.')
+    {
+        free (entry);
         return NULL;
+    }
     /* Handle recursion */
     if (p_sys->mode != MODE_COLLAPSE)
     {
         directory_t *sub = malloc (sizeof (*sub) + strlen (current->path) + 1
                                                  + strlen (entry));
         if (sub == NULL)
+        {
+            free (entry);
             return NULL;
+        }
         sprintf (sub->path, "%s/%s", current->path, entry);
 
         DIR *handle = utf8_opendir (sub->path);
@@ -373,7 +380,9 @@ static block_t *Block (access_t *p_access)
              || has_inode_loop (sub)
              || (sub->uri == NULL))
             {
+                free (entry);
                 closedir (handle);
+                free (sub->uri);
                 free (sub);
                 return NULL;
             }
@@ -382,9 +391,13 @@ static block_t *Block (access_t *p_access)
             /* Add node to xspf extension */
             char *old_xspf_extension = p_sys->psz_xspf_extension;
             if (old_xspf_extension == NULL)
+            {
+                free (entry);
                 goto fatal;
+            }
 
             char *title = convert_xml_special_chars (entry);
+            free (entry);
             if (title == NULL
              || asprintf (&p_sys->psz_xspf_extension, "%s"
                           "  <vlc:node title=\"%s\">\n", old_xspf_extension,
@@ -417,7 +430,10 @@ static block_t *Block (access_t *p_access)
 
                 if (type + extlen == end
                  && !strncasecmp (ext, type, extlen))
+                {
+                    free (entry);
                     return NULL;
+                }
 
                 if (*end == '\0')
                     break;
diff --git a/modules/access/qtcapture.m b/modules/access/qtcapture.m
index 088378f..a94f7d2 100644
--- a/modules/access/qtcapture.m
+++ b/modules/access/qtcapture.m
@@ -173,6 +173,7 @@ static int qtchroma_to_fourcc( int i_qt )
         /* Raw data types */
         { k422YpCbCr8CodecType,    VLC_FOURCC('U','Y','V','Y') },
         { kComponentVideoCodecType,VLC_FOURCC('Y','U','Y','2') },
+        { kComponentVideoUnsigned, VLC_FOURCC('U','Y','V','Y') },
         { 0, 0 }
     };
     int i;
diff --git a/modules/audio_filter/equalizer.c b/modules/audio_filter/equalizer.c
index 33b6469..ed9df4d 100644
--- a/modules/audio_filter/equalizer.c
+++ b/modules/audio_filter/equalizer.c
@@ -531,6 +531,7 @@ static int PresetCallback( vlc_object_t *p_this, char const *psz_cmd,
                     free( psz_newbands );
                     return VLC_ENOMEM;
                 }
+                free( psz_newbands );
                 psz_newbands = psz;
             }
             if( p_sys->b_first == false )
diff --git a/modules/audio_output/auhal.c b/modules/audio_output/auhal.c
index 1effe5b..58b25f0 100644
--- a/modules/audio_output/auhal.c
+++ b/modules/audio_output/auhal.c
@@ -993,6 +993,7 @@ static void Probe( aout_instance_t * p_aout )
         if( !AudioDeviceHasOutput( p_devices[i]) )
         {
             msg_Dbg( p_aout, "this device is INPUT only. skipping..." );
+            free( psz_name );
             continue;
         }
 
diff --git a/modules/codec/invmem.c b/modules/codec/invmem.c
index d672ecb..e8490b7 100644
--- a/modules/codec/invmem.c
+++ b/modules/codec/invmem.c
@@ -191,7 +191,6 @@ static picture_t *DecodeBlock( decoder_t *p_dec, block_t **pp_block )
     if( p_sys->p_pic != NULL )
         picture_Release( p_sys->p_pic );
     p_sys->p_pic = decoder_NewPicture( p_dec );
-    p_sys->p_pic = p_dec->pf_vout_buffer_new( p_dec );
     p_sys->p_pic->b_force = true;
     p_sys->p_pic->p->i_pitch = p_dec->p_sys->i_pitch;
     p_sys->p_pic->date = p_block->i_pts > 0 ? p_block->i_pts : p_block->i_dts;
diff --git a/modules/codec/x264.c b/modules/codec/x264.c
index 5004c2c..5602962 100644
--- a/modules/codec/x264.c
+++ b/modules/codec/x264.c
@@ -803,6 +803,7 @@ static int  Open ( vlc_object_t *p_this )
         return VLC_ENOMEM;
     p_sys->i_interpolated_dts = 0;
     p_sys->psz_stat_name = NULL;
+    p_sys->p_buffer = NULL;
 
     x264_param_default( &p_sys->param );
     p_sys->param.i_width  = p_enc->fmt_in.video.i_width;
@@ -1304,6 +1305,13 @@ static int  Open ( vlc_object_t *p_this )
     /* Open the encoder */
     p_sys->h = x264_encoder_open( &p_sys->param );
 
+    if( p_sys->h == NULL )
+    {
+        msg_Err( p_enc, "cannot open x264 encoder" );
+        Close( VLC_OBJECT(p_enc) );
+        return VLC_EGENERIC;
+    }
+
     /* alloc mem */
     p_sys->i_buffer = 4 * p_enc->fmt_in.video.i_width *
         p_enc->fmt_in.video.i_height + 1000;
@@ -1440,7 +1448,8 @@ static void Close( vlc_object_t *p_this )
 
     free( p_sys->psz_stat_name );
 
-    x264_encoder_close( p_sys->h );
+    if( p_sys->h )
+        x264_encoder_close( p_sys->h );
 
 #ifdef PTW32_STATIC_LIB
     vlc_value_t lock, count;
diff --git a/modules/control/dbus.c b/modules/control/dbus.c
index 2753140..5704672 100644
--- a/modules/control/dbus.c
+++ b/modules/control/dbus.c
@@ -32,7 +32,7 @@
  *  extract:
  *   "If you use this low-level API directly, you're signing up for some pain."
  *
- * MPRIS Specification (still drafting on Jan, 23 of 2008):
+ * MPRIS Specification version 1.0
  *      http://wiki.xmms2.xmms.se/index.php/MPRIS
  */
 
@@ -73,7 +73,7 @@ static int TrackListChangeEmit( intf_thread_t *, int, int );
 static int AllCallback( vlc_object_t*, const char*, vlc_value_t, vlc_value_t, void* );
 
 static int GetInputMeta ( input_item_t *, DBusMessageIter * );
-static int MarshalStatus ( intf_thread_t *, DBusMessageIter *, bool );
+static int MarshalStatus ( intf_thread_t *, DBusMessageIter * );
 static int UpdateCaps( intf_thread_t* );
 
 /* GetCaps() capabilities */
@@ -222,7 +222,7 @@ DBUS_METHOD( PositionSet )
 
     if( p_input )
     {
-        position.i_time = i_pos * 1000;
+        position.i_time = ((mtime_t)i_pos) * 1000;
         var_Set( p_input, "time", position );
         vlc_object_release( p_input );
     }
@@ -311,7 +311,7 @@ DBUS_METHOD( GetStatus )
     REPLY_INIT;
     OUT_ARGUMENTS;
 
-    MarshalStatus( p_this, &args, true );
+    MarshalStatus( p_this, &args );
 
     REPLY_SEND;
 }
@@ -838,12 +838,28 @@ static void Run          ( intf_thread_t *p_intf )
         int canc = vlc_savecancel();
         dbus_connection_read_write_dispatch( p_intf->p_sys->p_conn, 0 );
 
-        // Get the messages
+        /* Get the list of events to process
+         *
+         * We can't keep the lock on p_intf->p_sys->p_events, else we risk a
+         * deadlock:
+         * The signal functions could lock mutex X while p_events is locked;
+         * While some other function in vlc (playlist) might lock mutex X
+         * and then set a variable which would call AllCallback(), which itself
+         * needs to lock p_events to add a new event.
+         */
         vlc_mutex_lock( &p_intf->p_sys->lock );
-        for( int i = vlc_array_count( p_intf->p_sys->p_events ) - 1; i >= 0; i-- )
+        int i_events = vlc_array_count( p_intf->p_sys->p_events );
+        callback_info_t* info[i_events];
+        for( int i = i_events - 1; i >= 0; i-- )
         {
-            callback_info_t* info = vlc_array_item_at_index( p_intf->p_sys->p_events, i );
-            switch( info->signal )
+            info[i] = vlc_array_item_at_index( p_intf->p_sys->p_events, i );
+            vlc_array_remove( p_intf->p_sys->p_events, i );
+        }
+        vlc_mutex_unlock( &p_intf->p_sys->lock );
+
+        for( int i = 0; i < i_events; i++ )
+        {
+            switch( info[i]->signal )
             {
             case SIGNAL_ITEM_CURRENT:
                 TrackChange( p_intf );
@@ -851,7 +867,7 @@ static void Run          ( intf_thread_t *p_intf )
             case SIGNAL_INTF_CHANGE:
             case SIGNAL_PLAYLIST_ITEM_APPEND:
             case SIGNAL_PLAYLIST_ITEM_DELETED:
-                TrackListChangeEmit( p_intf, info->signal, info->i_node );
+                TrackListChangeEmit( p_intf, info[i]->signal, info[i]->i_node );
                 break;
             case SIGNAL_RANDOM:
             case SIGNAL_REPEAT:
@@ -859,15 +875,13 @@ static void Run          ( intf_thread_t *p_intf )
                 StatusChangeEmit( p_intf );
                 break;
             case SIGNAL_STATE:
-                StateChange( p_intf, info->i_input_state );
+                StateChange( p_intf, info[i]->i_input_state );
                 break;
             default:
                 assert(0);
             }
-            free( info );
-            vlc_array_remove( p_intf->p_sys->p_events, i );
+            free( info[i] );
         }
-        vlc_mutex_unlock( &p_intf->p_sys->lock );
         vlc_restorecancel( canc );
     }
 }
@@ -931,7 +945,7 @@ DBUS_SIGNAL( CapsChangeSignal )
 }
 
 /******************************************************************************
- * TrackListChange: tracklist order / length change signal 
+ * TrackListChange: tracklist order / length change signal
  *****************************************************************************/
 DBUS_SIGNAL( TrackListChangeSignal )
 { /* emit the new tracklist lengh */
@@ -1005,7 +1019,7 @@ DBUS_SIGNAL( StatusChangeSignal )
 
     /* we're called from a callback of input_thread_t, so it can not be
      * destroyed before we return */
-    MarshalStatus( (intf_thread_t*) p_data, &args, false );
+    MarshalStatus( (intf_thread_t*) p_data, &args );
 
     SIGNAL_SEND;
 }
@@ -1119,7 +1133,7 @@ static int UpdateCaps( intf_thread_t* p_intf )
     intf_sys_t* p_sys = p_intf->p_sys;
     dbus_int32_t i_caps = CAPS_CAN_HAS_TRACKLIST;
     playlist_t* p_playlist = pl_Hold( p_intf );
-    
+
     PL_LOCK;
     if( p_playlist->current.i_size > 0 )
         i_caps |= CAPS_CAN_PLAY | CAPS_CAN_GO_PREV | CAPS_CAN_GO_NEXT;
@@ -1233,8 +1247,7 @@ static int GetInputMeta( input_item_t* p_input,
  * MarshalStatus: Fill a DBusMessage with the current player status
  *****************************************************************************/
 
-static int MarshalStatus( intf_thread_t* p_intf, DBusMessageIter* args,
-                          bool lock )
+static int MarshalStatus( intf_thread_t* p_intf, DBusMessageIter* args )
 { /* This is NOT the right way to do that, it would be better to sore
      the status information in p_sys and update it on change, thus
      avoiding a long lock */
diff --git a/modules/control/http/http.c b/modules/control/http/http.c
index 75f24c2..6987029 100644
--- a/modules/control/http/http.c
+++ b/modules/control/http/http.c
@@ -27,6 +27,7 @@
 
 #include "http.h"
 #include <vlc_plugin.h>
+#include <vlc_url.h>
 
 #include <assert.h>
 
@@ -787,7 +788,8 @@ int  ArtCallback( httpd_handler_sys_t *p_args,
         psz_art = input_item_GetArtURL( p_item );
     }
 
-    if( psz_art && !strncmp( psz_art, "file://", strlen( "file://" ) ) )
+    if( psz_art && !strncmp( psz_art, "file://", strlen( "file://" ) ) &&
+        decode_URI( psz_art + 7 ) )
     {
         FILE *f;
         char *psz_ext;
diff --git a/modules/demux/mkv/mkv.cpp b/modules/demux/mkv/mkv.cpp
index f6b9f69..a66d090 100644
--- a/modules/demux/mkv/mkv.cpp
+++ b/modules/demux/mkv/mkv.cpp
@@ -42,7 +42,7 @@ static void Close( vlc_object_t * );
 vlc_module_begin ()
     set_shortname( "Matroska" )
     set_description( N_("Matroska stream demuxer" ) )
-    set_capability( "demux", 0 )
+    set_capability( "demux", 50 )
     set_callbacks( Open, Close )
     set_category( CAT_INPUT )
     set_subcategory( SUBCAT_INPUT_DEMUX )
diff --git a/modules/demux/playlist/xspf.c b/modules/demux/playlist/xspf.c
index ed1ed92..eee5b85 100644
--- a/modules/demux/playlist/xspf.c
+++ b/modules/demux/playlist/xspf.c
@@ -546,32 +546,31 @@ static bool parse_track_node COMPLEX_INTERFACE
                 /* special case: location */
                 if( !strcmp( p_handler->name, "location" ) )
                 {
-                    char *psz_uri = NULL;
-                    psz_uri = decode_URI_duplicate( psz_value );
+                    char *psz_location = psz_value;
+                    if( !strncmp( psz_value, "file://", 7 ) )
+                        psz_location = decode_URI( psz_value + 7 );
 
-                    if( !psz_uri )
+                    if( !psz_location )
                     {
                         FREE_ATT();
                         return false;
                     }
 
-                    if( p_demux->p_sys->psz_base && !strstr( psz_uri, "://" ) )
+                    if( p_demux->p_sys->psz_base && !strstr( psz_value, "://" ) )
                     {
                         char* psz_tmp;
                         if( asprintf( &psz_tmp, "%s%s", p_demux->p_sys->psz_base,
-                                      psz_uri ) == -1 )
+                                      psz_location ) == -1 )
                         {
-                            free( psz_uri );
                             FREE_ATT();
                             return NULL;
                         }
-                        free( psz_uri );
-                        psz_uri = psz_tmp;
+                        input_item_SetURI( p_new_input, psz_tmp );
+                        free( psz_tmp );
                     }
-                    input_item_SetURI( p_new_input, psz_uri );
-                    free( psz_uri );
+                    else
+                        input_item_SetURI( p_new_input, psz_location );
                     input_item_CopyOptions( p_input_item, p_new_input );
-                    psz_uri = NULL;
                     FREE_ATT();
                     p_handler = NULL;
                 }
@@ -652,9 +651,7 @@ static bool set_item_info SIMPLE_INTERFACE
     }
     else if( !strcmp( psz_name, "image" ) )
     {
-        char *psz_uri = decode_URI_duplicate( psz_value );
-        input_item_SetArtURL( p_input, psz_uri );
-        free( psz_uri );
+        input_item_SetArtURL( p_input, psz_value );
     }
     return true;
 }
diff --git a/modules/demux/vobsub.c b/modules/demux/vobsub.c
index 3b90e2d..bb0a47e 100644
--- a/modules/demux/vobsub.c
+++ b/modules/demux/vobsub.c
@@ -537,7 +537,7 @@ static int ParseVobSubIDX( demux_t *p_demux )
         }
         else if( !strncmp( "id:", line, 3 ) )
         {
-            char language[20];
+            char language[3];
             int i_track_id;
             es_format_t fmt;
 
@@ -547,6 +547,7 @@ static int ParseVobSubIDX( demux_t *p_demux )
             {
                 p_sys->i_tracks++;
                 p_sys->track = realloc( p_sys->track, sizeof( vobsub_track_t ) * (p_sys->i_tracks + 1 ) );
+                language[2] = '\0';
 
                 /* Init the track */
                 current_tk = &p_sys->track[p_sys->i_tracks - 1];
@@ -560,7 +561,7 @@ static int ParseVobSubIDX( demux_t *p_demux )
                 es_format_Init( &fmt, SPU_ES, VLC_FOURCC( 's','p','u',' ' ) );
                 fmt.subs.spu.i_original_frame_width = p_sys->i_original_frame_width;
                 fmt.subs.spu.i_original_frame_height = p_sys->i_original_frame_height;
-                fmt.psz_language = strdup( language );
+                fmt.psz_language = language;
                 if( p_sys->b_palette )
                 {
                     fmt.subs.spu.palette[0] = 0xBeef;
diff --git a/modules/gui/qt4/components/extended_panels.cpp b/modules/gui/qt4/components/extended_panels.cpp
index 464c27f..cf4d0cc 100644
--- a/modules/gui/qt4/components/extended_panels.cpp
+++ b/modules/gui/qt4/components/extended_panels.cpp
@@ -1340,7 +1340,7 @@ SyncControls::SyncControls( intf_thread_t *_p_intf, QWidget *_parent ) :
 
     QLabel *subSpeedLabel = new QLabel;
     subSpeedLabel->setText( qtr( "Speed of the subtitles:" ) );
-    subsLayout->addWidget( subSpeedLabel, 1, 0, 1, 3 );
+    subsLayout->addWidget( subSpeedLabel, 1, 0, 1, 1 );
 
     subSpeedSpin = new QDoubleSpinBox;
     subSpeedSpin->setAlignment( Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter );
diff --git a/modules/gui/qt4/components/sout/profile_selector.cpp b/modules/gui/qt4/components/sout/profile_selector.cpp
index 7c47163..3ebaa66 100644
--- a/modules/gui/qt4/components/sout/profile_selector.cpp
+++ b/modules/gui/qt4/components/sout/profile_selector.cpp
@@ -331,7 +331,7 @@ void VLCProfileEditor::fillProfile( const QString& qs )
     CHECKMUX( FLVMux, "flv" )
     CHECKMUX( MKVMux, "mkv" )
     CHECKMUX( AVIMux, "avi" )
-    CHECKMUX( MJPEGMux, "mjpg" ){}
+    CHECKMUX( MJPEGMux, "mpjpeg" ){}
 #undef CHECKMUX
 
     ui.keepVideo->setChecked( !options[1].toInt() );
@@ -420,7 +420,7 @@ QString VLCProfileEditor::transcodeValue()
     SMUX( FLVMux, "flv" )
     SMUX( MKVMux, "mkv" )
     SMUX( AVIMux, "avi" )
-    SMUX( MJPEGMux, "mjpg" ){}
+    SMUX( MJPEGMux, "mpjpeg" ){}
 #undef SMUX
 
 #define currentData( box ) box->itemData( box->currentIndex() )
diff --git a/modules/gui/qt4/input_manager.cpp b/modules/gui/qt4/input_manager.cpp
index 0b456ad..1fc1f49 100644
--- a/modules/gui/qt4/input_manager.cpp
+++ b/modules/gui/qt4/input_manager.cpp
@@ -29,6 +29,7 @@
 
 #include "input_manager.hpp"
 #include <vlc_keys.h>
+#include <vlc_url.h>
 
 #include <QApplication>
 
@@ -589,12 +590,12 @@ void InputManager::UpdateArt()
     if( hasInput() )
     {
         char *psz_art = input_item_GetArtURL( input_GetItem( p_input ) );
-        url = qfu( psz_art );
+        if( psz_art && !strncmp( psz_art, "file://", 7 ) &&
+                decode_URI( psz_art + 7 ) )
+            url = qfu( psz_art + 7);
         free( psz_art );
     }
-    url = url.replace( "file://", QString("" ) );
-    /* Taglib seems to define a attachment://, It won't work yet */
-    url = url.replace( "attachment://", QString("" ) );
+
     /* Update Art meta */
     emit artChanged( url );
 }
diff --git a/modules/meta_engine/folder.c b/modules/meta_engine/folder.c
index 4d41b0a..5a0c3a0 100644
--- a/modules/meta_engine/folder.c
+++ b/modules/meta_engine/folder.c
@@ -33,6 +33,7 @@
 #include <vlc_plugin.h>
 #include <vlc_playlist.h>
 #include <vlc_charset.h>
+#include <vlc_url.h>
 
 #ifdef HAVE_SYS_STAT_H
 #   include <sys/stat.h>
@@ -98,26 +99,31 @@ static int FindMeta( vlc_object_t *p_this )
             case 0:
             /* Windows Folder.jpg */
             snprintf( psz_filename, MAX_PATH,
-                      "file://%sFolder.jpg", psz_path );
+                      "%sFolder.jpg", psz_path );
             break;
 
             case 1:
             /* Windows AlbumArtSmall.jpg == small version of Folder.jpg */
             snprintf( psz_filename, MAX_PATH,
-                  "file://%sAlbumArtSmall.jpg", psz_path );
+                  "%sAlbumArtSmall.jpg", psz_path );
             break;
 
             case 2:
             /* KDE (?) .folder.png */
             snprintf( psz_filename, MAX_PATH,
-                  "file://%s.folder.png", psz_path );
+                  "%s.folder.png", psz_path );
             break;
         }
 
-        if( utf8_stat( psz_filename+7, &a ) != -1 )
+        if( utf8_stat( psz_filename, &a ) != -1 )
         {
-            input_item_SetArtURL( p_item, psz_filename );
-            b_have_art = true;
+            char *psz_uri = make_URI( psz_filename );
+            if( psz_uri )
+            {
+                input_item_SetArtURL( p_item, psz_uri );
+                free( psz_uri );
+                b_have_art = true;
+            }
         }
     }
 
diff --git a/modules/misc/notify/growl.m b/modules/misc/notify/growl.m
index c0503b0..95ad205 100644
--- a/modules/misc/notify/growl.m
+++ b/modules/misc/notify/growl.m
@@ -58,6 +58,7 @@
 #include <vlc_playlist.h>
 #include <vlc_meta.h>
 #include <vlc_interface.h>
+#include <vlc_url.h>
 
 
 /*****************************************************************************
@@ -210,7 +211,7 @@ static int ItemChange( vlc_object_t *p_this, const char *psz_var,
     char *psz_arturl = input_item_GetArtURL( p_item );
     CFDataRef art = NULL;
     if( psz_arturl && !strncmp( psz_arturl, "file://", 7 ) &&
-                    strlen( psz_arturl ) > 7 )
+                    decode_URI( psz_arturl + 7 ) )
         art = (CFDataRef) readFile( psz_arturl + 7 );
 
     free( psz_title );
diff --git a/modules/misc/notify/notify.c b/modules/misc/notify/notify.c
index 6b3be7c..6fa084a 100644
--- a/modules/misc/notify/notify.c
+++ b/modules/misc/notify/notify.c
@@ -32,6 +32,7 @@
 #include <vlc_plugin.h>
 #include <vlc_interface.h>
 #include <vlc_playlist.h>
+#include <vlc_url.h>
 
 #include <gdk-pixbuf/gdk-pixbuf.h>
 #include <libnotify/notify.h>
@@ -221,12 +222,11 @@ static int ItemChange( vlc_object_t *p_this, const char *psz_var,
     vlc_object_release( p_input );
 
     if( psz_arturl && !strncmp( psz_arturl, "file://", 7 ) &&
-                strlen( psz_arturl ) > 7 )
+                decode_URI( psz_arturl + 7 ) )
     { /* scale the art to show it in notify popup */
         GError *p_error = NULL;
         pix = gdk_pixbuf_new_from_file_at_scale( &psz_arturl[7],
                                                  72, 72, TRUE, &p_error );
-        free( psz_arturl );
     }
     else /* else we show state-of-the art logo */
     {
@@ -239,6 +239,8 @@ static int ItemChange( vlc_object_t *p_this, const char *psz_var,
         }
     }
 
+    free( psz_arturl );
+
     /* we need to replace '&' with '&amp;' because '&' is a keyword of
      * notification-daemon parser */
     const int i_len = strlen( psz_tmp );
diff --git a/modules/misc/playlist/xspf.c b/modules/misc/playlist/xspf.c
index 0f5f82c..6765adb 100644
--- a/modules/misc/playlist/xspf.c
+++ b/modules/misc/playlist/xspf.c
@@ -212,9 +212,7 @@ static void xspf_export_item( playlist_item_t *p_item, FILE *p_file,
     if( psz == NULL ) psz = strdup( "" );
     if( !EMPTY_STR( psz ) )
     {
-        psz_uri = make_URI( psz );
-        fprintf( p_file, "\t\t\t<image>%s</image>\n", psz_uri );
-        free( psz_uri );
+        fprintf( p_file, "\t\t\t<image>%s</image>\n", psz );
     }
     free( psz );
 
diff --git a/modules/misc/quartztext.c b/modules/misc/quartztext.c
index a19c2a3..3a8c7db 100644
--- a/modules/misc/quartztext.c
+++ b/modules/misc/quartztext.c
@@ -749,7 +749,9 @@ static offscreen_bitmap_t *Compose( int i_text_align, UniChar *psz_utf16_str, ui
             CGContextSetTextDrawingMode( p_context, kCGTextFillStroke );
             CGContextSetShadow( p_context, CGSizeMake( 0, 0 ), 5 );
             float black_components[4] = {0, 0, 0, 1};
-            CGContextSetShadowWithColor (p_context, CGSizeMake( 0, 0 ), 5, CGColorCreate( CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB ), black_components ));
+            CGColorRef outlinecolor = CGColorCreate( CGColorSpaceCreateWithName( kCGColorSpaceGenericRGB ), black_components );
+            CGContextSetShadowWithColor (p_context, CGSizeMake( 0, 0 ), 5, outlinecolor);
+            CGColorRelease( outlinecolor );
             do
             {
                 // ATSUBreakLine will automatically pick up any manual '\n's also
diff --git a/modules/stream_out/rtp.c b/modules/stream_out/rtp.c
index edd06c6..c4770f5 100644
--- a/modules/stream_out/rtp.c
+++ b/modules/stream_out/rtp.c
@@ -853,10 +853,8 @@ static sout_stream_id_t *Add( sout_stream_t *p_stream, es_format_t *p_fmt )
      * mux (TS/PS), then p_fmt is NULL. */
     sout_stream_sys_t *p_sys = p_stream->p_sys;
     sout_stream_id_t  *id;
-    int               i_port, cscov = -1;
+    int               cscov = -1;
     char              *psz_sdp;
-    int               i_port_audio_option = var_GetInteger( p_stream, "port-audio" );
-    int               i_port_video_option = var_GetInteger( p_stream, "port-video" );
 
     if (0xffffffff == p_sys->payload_bitmap)
     {
@@ -864,38 +862,41 @@ static sout_stream_id_t *Add( sout_stream_t *p_stream, es_format_t *p_fmt )
         return NULL;
     }
 
-    id = vlc_object_create( p_stream, sizeof( sout_stream_id_t ) );
-    if( id == NULL )
-        return NULL;
-    vlc_object_attach( id, p_stream );
-
     /* Choose the port */
-    i_port = 0;
+    uint16_t i_port = 0;
     if( p_fmt == NULL )
         ;
     else
     if( p_fmt->i_cat == AUDIO_ES && p_sys->i_port_audio > 0 )
-    {
         i_port = p_sys->i_port_audio;
-        p_sys->i_port_audio = 0;
-    }
     else
     if( p_fmt->i_cat == VIDEO_ES && p_sys->i_port_video > 0 )
-    {
         i_port = p_sys->i_port_video;
-        p_sys->i_port_video = 0;
-    }
 
-    while( i_port == 0 )
+    /* We do not need the ES lock (p_sys->lock_es) here, because this is the
+     * only one thread that can *modify* the ES table. The ES lock protects
+     * the other threads from our modifications (TAB_APPEND, TAB_REMOVE). */
+    for (int i = 0; i_port && (i < p_sys->i_es); i++)
+         if (i_port == p_sys->es[i]->i_port)
+             i_port = 0; /* Port already in use! */
+    for (uint16_t p = p_sys->i_port; i_port == 0; p += 2)
     {
-        if( p_sys->i_port != i_port_audio_option
-         && p_sys->i_port != i_port_video_option )
+        if (p == 0)
         {
-            i_port = p_sys->i_port;
+            msg_Err (p_stream, "too many RTP elementary streams");
+            return NULL;
         }
-        p_sys->i_port += 2;
+        i_port = p;
+        for (int i = 0; i_port && (i < p_sys->i_es); i++)
+             if (p == p_sys->es[i]->i_port)
+                 i_port = 0;
     }
 
+    id = vlc_object_create( p_stream, sizeof( sout_stream_id_t ) );
+    if( id == NULL )
+        return NULL;
+    vlc_object_attach( id, p_stream );
+
     id->p_stream   = p_stream;
 
     /* Look for free dymanic payload type */
@@ -1311,11 +1312,6 @@ static int Del( sout_stream_t *p_stream, sout_stream_id_t *id )
     TAB_REMOVE( p_sys->i_es, p_sys->es, id );
     vlc_mutex_unlock( &p_sys->lock_es );
 
-    /* Release port */
-    if( id->i_port == var_GetInteger( p_stream, "port-audio" ) )
-        p_sys->i_port_audio = id->i_port;
-    if( id->i_port == var_GetInteger( p_stream, "port-video" ) )
-        p_sys->i_port_video = id->i_port;
     /* Release dynamic payload type */
     if (id->i_payload_type >= 96)
         p_sys->payload_bitmap &= ~(1 << (id->i_payload_type - 96));
diff --git a/share/lua/meta/10_googleimage.lua b/share/lua/meta/10_googleimage.lua
index e203c9c..8dc1e04 100644
--- a/share/lua/meta/10_googleimage.lua
+++ b/share/lua/meta/10_googleimage.lua
@@ -44,9 +44,5 @@ function fetch_art()
     page = fd:read( 65653 )
     fd = nil
     _, _, arturl = string.find( page, "imgurl=([^&]+)" )
-    if arturl then
-        return vlc.strings.decode_uri(arturl)
-    else
-        return nil
-    end
+    return arturl
 end
diff --git a/share/lua/playlist/dailymotion.lua b/share/lua/playlist/dailymotion.lua
index e850bcf..f4545c6 100644
--- a/share/lua/playlist/dailymotion.lua
+++ b/share/lua/playlist/dailymotion.lua
@@ -41,7 +41,7 @@ function parse()
         if not line then break end
         if string.match( line, "param name=\"flashvars\" value=\".*video=" )
         then
-            arturl = vlc.strings.decode_uri( find( line, "param name=\"flashvars\" value=\".*preview=([^&]*)" ) )
+            arturl = find( line, "param name=\"flashvars\" value=\".*preview=([^&]*)" )
             videos = vlc.strings.decode_uri( find( line, "param name=\"flashvars\" value=\".*video=([^&]*)" ) )
        --[[ we get a list of different streams available, at various codecs
             and resolutions:
diff --git a/share/lua/playlist/youtube.lua b/share/lua/playlist/youtube.lua
index 452400f..238d3eb 100644
--- a/share/lua/playlist/youtube.lua
+++ b/share/lua/playlist/youtube.lua
@@ -26,7 +26,7 @@ end
 
 function get_arturl( path, video_id )
     if string.match( vlc.path, "iurl=" ) then
-        return vlc.strings.decode_uri( get_url_param( vlc.path, "iurl" ) )
+        return vlc.strings( get_url_param( vlc.path, "iurl" ) )
     end
     if not arturl then
         return "http://img.youtube.com/vi/"..video_id.."/default.jpg"
diff --git a/src/control/libvlc_internal.h b/src/control/libvlc_internal.h
index 417d38e..053716b 100644
--- a/src/control/libvlc_internal.h
+++ b/src/control/libvlc_internal.h
@@ -90,6 +90,7 @@ struct libvlc_media_list_t
     libvlc_instance_t *         p_libvlc_instance;
     int                         i_refcount;
     vlc_mutex_t                 object_lock;
+    vlc_mutex_t                 refcount_lock;
     libvlc_media_t * p_md; /* The media from which the
                                        * mlist comes, if any. */
     vlc_array_t                items;
diff --git a/src/control/media_list.c b/src/control/media_list.c
index e043c4c..0bb2276 100644
--- a/src/control/media_list.c
+++ b/src/control/media_list.c
@@ -170,6 +170,7 @@ libvlc_media_list_new( libvlc_instance_t * p_inst,
     }
 
     vlc_mutex_init( &p_mlist->object_lock );
+    vlc_mutex_init( &p_mlist->refcount_lock ); // FIXME: spinlock?
 
     vlc_array_init( &p_mlist->items );
     p_mlist->i_refcount = 1;
@@ -188,14 +189,14 @@ void libvlc_media_list_release( libvlc_media_list_t * p_mlist )
     libvlc_media_t * p_md;
     int i;
 
-    vlc_mutex_lock( &p_mlist->object_lock );
+    vlc_mutex_lock( &p_mlist->refcount_lock );
     p_mlist->i_refcount--;
     if( p_mlist->i_refcount > 0 )
     {
-        vlc_mutex_unlock( &p_mlist->object_lock );
+        vlc_mutex_unlock( &p_mlist->refcount_lock );
         return;
     }
-    vlc_mutex_unlock( &p_mlist->object_lock );
+    vlc_mutex_unlock( &p_mlist->refcount_lock );
 
     /* Refcount null, time to free */
 
@@ -223,9 +224,9 @@ void libvlc_media_list_release( libvlc_media_list_t * p_mlist )
  **************************************************************************/
 void libvlc_media_list_retain( libvlc_media_list_t * p_mlist )
 {
-    vlc_mutex_lock( &p_mlist->object_lock );
+    vlc_mutex_lock( &p_mlist->refcount_lock );
     p_mlist->i_refcount++;
-    vlc_mutex_unlock( &p_mlist->object_lock );
+    vlc_mutex_unlock( &p_mlist->refcount_lock );
 }
 
 
diff --git a/src/libvlccore.sym b/src/libvlccore.sym
index d72c10f..4f201d3 100644
--- a/src/libvlccore.sym
+++ b/src/libvlccore.sym
@@ -380,8 +380,6 @@ tls_ClientCreate
 tls_ClientDelete
 ToLocale
 ToLocaleDup
-unescape_URI
-unescape_URI_duplicate
 update_Check
 update_Delete
 update_Download
diff --git a/src/misc/mtime.c b/src/misc/mtime.c
index c735bdf..a0c24e8 100644
--- a/src/misc/mtime.c
+++ b/src/misc/mtime.c
@@ -56,7 +56,8 @@
 #   include <sys/time.h>
 #endif
 
-#ifdef __APPLE__
+#if defined(__APPLE__) && !defined(__powerpc__) && !defined(__ppc__) && !defined(__ppc64__)
+#define USE_APPLE_MACH 1
 #   include <mach/mach.h>
 #   include <mach/mach_time.h>
 #endif
@@ -173,7 +174,7 @@ static inline unsigned mprec( void )
 #endif
 }
 
-#ifdef __APPLE__
+#ifdef USE_APPLE_MACH
 static mach_timebase_info_data_t mtime_timebase_info;
 static pthread_once_t mtime_timebase_info_once = PTHREAD_ONCE_INIT;
 static void mtime_init_timebase(void)
@@ -207,7 +208,7 @@ mtime_t mdate( void )
 #elif defined( HAVE_KERNEL_OS_H )
     res = real_time_clock_usecs();
 
-#elif defined( __APPLE__ )
+#elif defined( USE_APPLE_MACH )
     pthread_once(&mtime_timebase_info_once, mtime_init_timebase);
     uint64_t date = mach_absolute_time();
 
@@ -323,7 +324,7 @@ mtime_t mdate( void )
         i_previous_time = res;
         LeaveCriticalSection( &date_lock );
     }
-#elif defined( __APPLE__ ) /* The version that should be used, if it was cancelable */
+#elif USE_APPLE_MACH /* The version that should be used, if it was cancelable */
     pthread_once(&mtime_timebase_info_once, mtime_init_timebase);
     uint64_t mach_time = date * 1000 * mtime_timebase_info.denom / mtime_timebase_info.numer;
     mach_wait_until(mach_time);
@@ -424,7 +425,7 @@ void msleep( mtime_t delay )
 
     while( nanosleep( &ts_delay, &ts_delay ) && ( errno == EINTR ) );
 
-#elif defined( __APPLE__ ) /* The version that should be used, if it was cancelable */
+#elif USE_APPLE_MACH /* The version that should be used, if it was cancelable */
     pthread_once(&mtime_timebase_info_once, mtime_init_timebase);
     uint64_t mach_time = delay * 1000 * mtime_timebase_info.denom / mtime_timebase_info.numer;
     mach_wait_until(mach_time + mach_absolute_time());
diff --git a/src/misc/threads.c b/src/misc/threads.c
index 149e761..71d0afe 100644
--- a/src/misc/threads.c
+++ b/src/misc/threads.c
@@ -618,7 +618,7 @@ int vlc_cond_timedwait (vlc_cond_t *p_condvar, vlc_mutex_t *p_mutex,
                         mtime_t deadline)
 {
 #if defined(LIBVLC_USE_PTHREAD)
-#ifdef __APPLE__
+#if defined(__APPLE__) && !defined(__powerpc__) && !defined( __ppc__ ) && !defined( __ppc64__ )
     /* mdate() is mac_absolute_time on osx, which we must convert to do
      * the same base than gettimeofday() on which pthread_cond_timedwait
      * counts on. */
diff --git a/src/playlist/art.c b/src/playlist/art.c
index 002ec6e..8b65121 100644
--- a/src/playlist/art.c
+++ b/src/playlist/art.c
@@ -32,6 +32,8 @@
 #include <vlc_charset.h>
 #include <vlc_strings.h>
 #include <vlc_stream.h>
+#include <vlc_url.h>
+
 #include <limits.h>                                             /* PATH_MAX */
 
 #ifdef HAVE_SYS_STAT_H
@@ -132,7 +134,7 @@ static char *ArtCacheName( input_item_t *p_item, const char *psz_type )
 
     char *psz_ext = filename_sanitize( psz_type ? psz_type : "" );
     char *psz_filename;
-    if( asprintf( &psz_filename, "file://%s" DIR_SEP "art%s", psz_path, psz_ext ) < 0 )
+    if( asprintf( &psz_filename, "%s" DIR_SEP "art%s", psz_path, psz_ext ) < 0 )
         psz_filename = NULL;
 
     free( psz_ext );
@@ -164,12 +166,19 @@ int playlist_FindArtInCache( input_item_t *p_item )
         if( !strncmp( psz_filename, "art", 3 ) )
         {
             char *psz_file;
-            if( asprintf( &psz_file, "file://%s" DIR_SEP "%s",
+            if( asprintf( &psz_file, "%s" DIR_SEP "%s",
                           psz_path, psz_filename ) < 0 )
                 psz_file = NULL;
             if( psz_file )
-                input_item_SetArtURL( p_item, psz_file );
-            free( psz_file );
+            {
+                char *psz_uri = make_URI( psz_file );
+                if( psz_uri )
+                {
+                    input_item_SetArtURL( p_item, psz_uri );
+                    free( psz_uri );
+                }
+                free( psz_file );
+            }
 
             b_found = true;
         }
@@ -192,17 +201,25 @@ int playlist_SaveArt( playlist_t *p_playlist, input_item_t *p_item,
     if( !psz_filename )
         return VLC_EGENERIC;
 
+    char *psz_uri = make_URI( psz_filename );
+    if( !psz_uri )
+    {
+        free( psz_filename );
+        return VLC_EGENERIC;
+    }
+
     /* Check if we already dumped it */
     struct stat s;
-    if( !utf8_stat( psz_filename+7, &s ) )
+    if( !utf8_stat( psz_filename, &s ) )
     {
-        input_item_SetArtURL( p_item, psz_filename );
+        input_item_SetArtURL( p_item, psz_uri );
         free( psz_filename );
+        free( psz_uri );
         return VLC_SUCCESS;
     }
 
     /* Dump it otherwise */
-    FILE *f = utf8_fopen( psz_filename+7, "wb" );
+    FILE *f = utf8_fopen( psz_filename, "wb" );
     if( f )
     {
         if( fwrite( p_buffer, i_buffer, 1, f ) != 1 )
@@ -212,11 +229,12 @@ int playlist_SaveArt( playlist_t *p_playlist, input_item_t *p_item,
         else
         {
             msg_Dbg( p_playlist, "album art saved to %s", psz_filename );
-            input_item_SetArtURL( p_item, psz_filename );
+            input_item_SetArtURL( p_item, psz_uri );
         }
         fclose( f );
     }
     free( psz_filename );
+    free( psz_uri );
     return VLC_SUCCESS;
 }
 
diff --git a/src/text/strings.c b/src/text/strings.c
index 9c6d931..736bb87 100644
--- a/src/text/strings.c
+++ b/src/text/strings.c
@@ -49,89 +49,6 @@
 #include <vlc_charset.h>
 
 /**
- * Unescape URI encoded string
- * \return decoded duplicated string
- */
-char *unescape_URI_duplicate( const char *psz )
-{
-    char *psz_dup = strdup( psz );
-    unescape_URI( psz_dup );
-    return psz_dup;
-}
-
-/**
- * Unescape URI encoded string in place
- * \return nothing
- */
-void unescape_URI( char *psz )
-{
-    unsigned char *in = (unsigned char *)psz, *out = in, c;
-    if( psz == NULL )
-        return;
-
-    while( ( c = *in++ ) != '\0' )
-    {
-        switch( c )
-        {
-            case '%':
-            {
-                char val[5], *pval = val;
-                unsigned long cp;
-
-                switch( c = *in++ )
-                {
-                    case '\0':
-                        return;
-
-                    case 'u':
-                    case 'U':
-                        if( ( *pval++ = *in++ ) == '\0' )
-                            return;
-                        if( ( *pval++ = *in++ ) == '\0' )
-                            return;
-                        c = *in++;
-
-                    default:
-                        *pval++ = c;
-                        if( ( *pval++ = *in++ ) == '\0' )
-                            return;
-                        *pval = '\0';
-                }
-
-                cp = strtoul( val, NULL, 0x10 );
-                if( cp < 0x80 )
-                    *out++ = cp;
-                else
-                if( cp < 0x800 )
-                {
-                    *out++ = (( cp >>  6)         | 0xc0);
-                    *out++ = (( cp        & 0x3f) | 0x80);
-                }
-                else
-                {
-                    assert( cp < 0x10000 );
-                    *out++ = (( cp >> 12)         | 0xe0);
-                    *out++ = (((cp >>  6) & 0x3f) | 0x80);
-                    *out++ = (( cp        & 0x3f) | 0x80);
-                }
-                break;
-            }
-
-            /* + is not a special case - it means plus, not space. */
-
-            default:
-                /* Inserting non-ASCII or non-printable characters is unsafe,
-                 * and no sane browser will send these unencoded */
-                if( ( c < 32 ) || ( c > 127 ) )
-                    *out++ = '?';
-                else
-                    *out++ = c;
-        }
-    }
-    *out = '\0';
-}
-
-/**
  * Decode encoded URI component. See also decode_URI().
  * \return decoded duplicated string
  */
diff --git a/test/libvlc/media_list_player.c b/test/libvlc/media_list_player.c
index 712e0fe..49a1443 100644
--- a/test/libvlc/media_list_player.c
+++ b/test/libvlc/media_list_player.c
@@ -92,8 +92,11 @@ static void test_media_list_player_play_item_at_index(const char** argv, int arg
 
     mlp = libvlc_media_list_player_new (vlc, &ex);
 
-    libvlc_media_list_add_media( ml, md, &ex );
-    catch ();
+    for (unsigned i = 0; i < 5; i++)
+    {
+        libvlc_media_list_add_media( ml, md, &ex );
+        catch ();
+    }
 
     libvlc_media_list_player_set_media_list( mlp, ml, &ex );
 
diff --git a/test/libvlc/test.h b/test/libvlc/test.h
index 388a465..1015d25 100644
--- a/test/libvlc/test.h
+++ b/test/libvlc/test.h
@@ -100,7 +100,7 @@ static inline void catch (void)
 static inline void test_init (void)
 {
     (void)test_default_sample; /* This one may not be used */
-    alarm (50); /* Make sure "make check" does not get stuck */
+    alarm (10); /* Make sure "make check" does not get stuck */
 }
 
 #endif /* TEST_H */
